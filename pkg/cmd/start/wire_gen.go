// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package start

import (
	"context"
	"github.com/Mandala/go-log"
	"github.com/bobvawter/cacheroach/pkg/bootstrap"
	"github.com/bobvawter/cacheroach/pkg/cache"
	"github.com/bobvawter/cacheroach/pkg/enforcer"
	"github.com/bobvawter/cacheroach/pkg/server"
	"github.com/bobvawter/cacheroach/pkg/server/common"
	"github.com/bobvawter/cacheroach/pkg/server/diag"
	"github.com/bobvawter/cacheroach/pkg/server/rest"
	"github.com/bobvawter/cacheroach/pkg/server/rpc"
	"github.com/bobvawter/cacheroach/pkg/store/auth"
	"github.com/bobvawter/cacheroach/pkg/store/blob"
	"github.com/bobvawter/cacheroach/pkg/store/config"
	"github.com/bobvawter/cacheroach/pkg/store/fs"
	"github.com/bobvawter/cacheroach/pkg/store/principal"
	"github.com/bobvawter/cacheroach/pkg/store/storeproduction"
	"github.com/bobvawter/cacheroach/pkg/store/tenant"
	"github.com/bobvawter/cacheroach/pkg/store/token"
	"github.com/bobvawter/cacheroach/pkg/store/upload"
	"github.com/bobvawter/cacheroach/pkg/store/vhost"
)

// Injectors from injector.go:

func newInjector(contextContext context.Context, cacheConfig *cache.Config, configConfig *config.Config, commonConfig *common.Config, logger *log.Logger) (*injector, func(), error) {
	busyLatch := rest.ProvideBusyLatch()
	v, err := server.ProvideCertificates(commonConfig, logger)
	if err != nil {
		return nil, nil, err
	}
	cacheCache, cleanup, err := cache.ProvideCache(contextContext, cacheConfig, logger)
	if err != nil {
		return nil, nil, err
	}
	pool, err := storeproduction.ProvideDB(contextContext, configConfig, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	store, cleanup2 := blob.ProvideStore(contextContext, cacheCache, configConfig, pool, logger)
	tokenServer, err := token.ProvideServer(configConfig, pool, logger)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	enforcerEnforcer := enforcer.ProvideEnforcer(logger, tokenServer)
	fsStore, cleanup3, err := fs.ProvideStore(contextContext, store, configConfig, pool, logger)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	pProfWrapper := rest.ProvidePProfWrapper()
	latchWrapper := rest.ProvideLatchWrapper(busyLatch)
	principalServer := &principal.Server{
		Config: configConfig,
		DB:     pool,
		Logger: logger,
	}
	tenantServer := &tenant.Server{
		DB:     pool,
		Logger: logger,
	}
	vhostServer := &vhost.Server{
		DB:     pool,
		Logger: logger,
	}
	bootstrapper, err := bootstrap.ProvideBootstrap(contextContext, store, pool, fsStore, logger, principalServer, tokenServer, tenantServer, vhostServer)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	sessionWrapper := rest.ProvideSessionWrapper(bootstrapper, tokenServer)
	vHostMap, cleanup4, err := common.ProvideVHostMap(contextContext, logger, vhostServer)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	vHostWrapper := rest.ProvideVHostWrapper(logger, vHostMap)
	fileHandler := rest.ProvideFileHandler(store, enforcerEnforcer, fsStore, logger, pProfWrapper, latchWrapper, sessionWrapper, vHostWrapper)
	healthz := rest.ProvideHealthz(pool, logger)
	retrieve := rest.ProvideRetrieve(logger, fsStore, pProfWrapper, latchWrapper, sessionWrapper, vHostWrapper)
	authInterceptor, err := rpc.ProvideAuthInterceptor(logger, tokenServer)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	elideInterceptor := &rpc.ElideInterceptor{
		Enforcer: enforcerEnforcer,
	}
	vHostInterceptor := &rpc.VHostInterceptor{
		Logger: logger,
		Mapper: vHostMap,
	}
	authServer := &auth.Server{
		DB:         pool,
		Principals: principalServer,
		Tokens:     tokenServer,
	}
	diags := &diag.Diags{}
	fsServer := &fs.Server{
		Config: configConfig,
		DB:     pool,
		FS:     fsStore,
	}
	uploadServer, err := upload.ProvideServer(store, configConfig, pool, fsStore, logger)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	grpcServer, err := rpc.ProvideRPC(logger, authInterceptor, elideInterceptor, vHostInterceptor, authServer, diags, fsServer, principalServer, tenantServer, tokenServer, uploadServer, vhostServer)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	mux := rest.ProvideMux(commonConfig, logger, fileHandler, healthz, retrieve, grpcServer)
	serverServer, cleanup5, err := server.ProvideServer(contextContext, busyLatch, v, commonConfig, logger, mux, tokenServer)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	startInjector := &injector{
		Server: serverServer,
	}
	return startInjector, func() {
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// injector.go:

type injector struct {
	Server *server.Server
}
