// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//+build !wireinject

package start

import (
	"context"
	"github.com/Mandala/go-log"
	"github.com/bobvawter/cacheroach/pkg/bootstrap"
	"github.com/bobvawter/cacheroach/pkg/cache"
	"github.com/bobvawter/cacheroach/pkg/enforcer"
	"github.com/bobvawter/cacheroach/pkg/metrics"
	"github.com/bobvawter/cacheroach/pkg/server"
	"github.com/bobvawter/cacheroach/pkg/server/common"
	"github.com/bobvawter/cacheroach/pkg/server/diag"
	"github.com/bobvawter/cacheroach/pkg/server/oidc"
	"github.com/bobvawter/cacheroach/pkg/server/rest"
	"github.com/bobvawter/cacheroach/pkg/server/rpc"
	"github.com/bobvawter/cacheroach/pkg/store/blob"
	"github.com/bobvawter/cacheroach/pkg/store/config"
	"github.com/bobvawter/cacheroach/pkg/store/fs"
	"github.com/bobvawter/cacheroach/pkg/store/principal"
	"github.com/bobvawter/cacheroach/pkg/store/storeproduction"
	"github.com/bobvawter/cacheroach/pkg/store/tenant"
	"github.com/bobvawter/cacheroach/pkg/store/token"
	"github.com/bobvawter/cacheroach/pkg/store/upload"
	"github.com/bobvawter/cacheroach/pkg/store/vhost"
	"github.com/prometheus/client_golang/prometheus"
)

// Injectors from injector.go:

func newInjector(contextContext context.Context, cacheConfig *cache.Config, configConfig *config.Config, commonConfig *common.Config, logger *log.Logger) (*injector, func(), error) {
	registry := prometheus.NewPedanticRegistry()
	factory := metrics.ProvideFactory(registry)
	busyLatch := common.ProvideBusyLatch(factory)
	v, err := server.ProvideCertificates(commonConfig, logger)
	if err != nil {
		return nil, nil, err
	}
	handler := metrics.ProvideMetricsHandler(logger, registry, registry)
	pool, err := storeproduction.ProvideDB(contextContext, configConfig, logger)
	if err != nil {
		return nil, nil, err
	}
	healthz := rest.ProvideHealthz(pool, logger)
	debugMux := rest.ProvideDebugMux(handler, healthz)
	latchWrapper := rest.ProvideLatchWrapper(busyLatch)
	pProfWrapper := rest.ProvidePProfWrapper()
	cacheCache, cleanup, err := cache.ProvideCache(contextContext, factory, cacheConfig, logger)
	if err != nil {
		return nil, nil, err
	}
	store, cleanup2 := blob.ProvideStore(contextContext, cacheCache, configConfig, pool, logger)
	fsStore, cleanup3, err := fs.ProvideStore(contextContext, store, configConfig, pool, logger)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	principalServer := &principal.Server{
		Config: configConfig,
		DB:     pool,
		Logger: logger,
	}
	tokenServer, err := token.ProvideServer(configConfig, pool, logger)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	tenantServer := &tenant.Server{
		DB:     pool,
		Logger: logger,
	}
	vhostServer := &vhost.Server{
		DB:     pool,
		Logger: logger,
	}
	bootstrapper, err := bootstrap.ProvideBootstrap(contextContext, store, pool, fsStore, logger, principalServer, tokenServer, tenantServer, vhostServer)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	connector, err := oidc.ProvideConnector(contextContext, factory, bootstrapper, commonConfig, logger, principalServer, tokenServer)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	sessionWrapper := rest.ProvideSessionWrapper(bootstrapper, connector, tokenServer)
	vHostMap, cleanup4, err := common.ProvideVHostMap(contextContext, logger, vhostServer)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	vHostWrapper := rest.ProvideVHostWrapper(logger, vHostMap)
	cliConfigHandler := rest.ProvideCLIConfigHandler(commonConfig, latchWrapper, pProfWrapper, sessionWrapper, vHostWrapper)
	enforcerEnforcer := enforcer.ProvideEnforcer(logger, tokenServer)
	fileHandler := rest.ProvideFileHandler(store, enforcerEnforcer, fsStore, logger, pProfWrapper, latchWrapper, sessionWrapper, vHostWrapper)
	wrapper := metrics.ProvideWrapper(factory)
	provision, err := rest.ProvideProvision(commonConfig, connector, logger, principalServer, pProfWrapper, latchWrapper, sessionWrapper, vHostWrapper)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	retrieve := rest.ProvideRetrieve(logger, fsStore, pProfWrapper, latchWrapper, sessionWrapper, vHostWrapper)
	authInterceptor, err := rpc.ProvideAuthInterceptor(connector, logger, tokenServer)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	busyInterceptor := &rpc.BusyInterceptor{
		BusyLatch: busyLatch,
	}
	elideInterceptor := &rpc.ElideInterceptor{
		Enforcer: enforcerEnforcer,
	}
	interceptor := metrics.ProvideInterceptor(factory)
	vHostInterceptor := &rpc.VHostInterceptor{
		Logger: logger,
		Mapper: vHostMap,
	}
	diags := &diag.Diags{}
	fsServer := &fs.Server{
		Config: configConfig,
		DB:     pool,
		FS:     fsStore,
	}
	uploadServer, err := upload.ProvideServer(store, configConfig, pool, fsStore, logger)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	grpcServer, err := rpc.ProvideRPC(logger, authInterceptor, busyInterceptor, elideInterceptor, interceptor, vHostInterceptor, diags, fsServer, principalServer, tenantServer, tokenServer, uploadServer, vhostServer)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	publicMux := rest.ProvidePublicMux(cliConfigHandler, connector, fileHandler, wrapper, provision, retrieve, grpcServer)
	serverServer, cleanup5, err := server.ProvideServer(contextContext, busyLatch, v, commonConfig, debugMux, logger, publicMux)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	startInjector := &injector{
		Server: serverServer,
	}
	return startInjector, func() {
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// injector.go:

type injector struct {
	Server *server.Server
}
